<!--
  Title: index.html
  Summary: babylon.js driver html file for tutorials and the bjs_test video
  Owner: Zachary Fout
  Version: 0.0.1
  Created: 06/20/2016
  Last Modified: 06/21/2016
  Notes: completed basic scene tutorial
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html" charset="utf-8" />
    <title>Babylon - Getting Started</title>
    <!-- link to the latest version of babylon -->
    <script src="./js/babylon.2.4.js"></script>
    <script src="./js/hand.1.2.js"></script>
    <script src="./js/cannon.2.4.js"></script>
    <script src="./js/oimo.2.4.js"></script>
    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      } #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>
    <script>
      window.addEventListener('DOMContentLoaded', function() {
        // get a reference to the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the Babylon 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // create and return a babylon scene
        var createScene = function () {
          var scene = new BABYLON.Scene(engine);
          scene.enablePhysics(new BABYLON.Vector3(0, -0.8, 0), BABYLON.OimoJSPlugin());

          /* var camera = new BABYLON.ArcRotateCamera("ArcCamera", 1, 0.8, 10, new BABYLON.Vector3(0, 100, -400), scene);
          camera.setTarget(BABYLON.Vector3.Zero());
          camera.attachControl(canvas, true); */

          var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(50, 100, 315), scene);
            camera.rotation = new BABYLON.Vector3(0.3, Math.PI, 0);
            camera.rotation.y = Math.PI + 0.2;
          //camera.setTarget(BABYLON.Vector3.Zero());
          camera.attachControl(canvas, true);

          var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
          light.intensity = 0.7;

          var light1 = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(200, -300, 300), scene);

          var lightSphere = BABYLON.Mesh.CreateSphere("lightSphere", 10, 10.0, scene, true);
          lightSphere.position = light1.position;
          lightSphere.material = new BABYLON.StandardMaterial("light", scene);
          lightSphere.material.emmissiveColor = new BABYLON.Color3(1, 1, 0);

          var shadowGenerator = new BABYLON.ShadowGenerator(1024, light1);
          shadowGenerator.getShadowMap().renderList.push(sphere);
          shadowGenerator.useVarianceMap = true;

          // Ground
          var ground = BABYLON.Mesh.CreatePlane("ground", 150.0, scene);
          ground.material = new BABYLON.StandardMaterial("groundMat", scene);
          ground.material.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
          ground.material.backFaceCulling = false;
          ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
          ground.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.1 });
          ground.updatePhysicsBody();
          ground.receiveShadows = true;
          ground.isPickable = true;

          var dragWall = BABYLON.Mesh.CreatePlane("drag", 150.0, scene);
          dragWall.material = new BABYLON.StandardMaterial("dragMat", scene);
          dragWall.material.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
          dragWall.position = new BABYLON.Vector3(0, 75, 75);
          dragWall.material.frontFaceCulling = true;
          //dragWall.material.backFaceCulling = false;

          var boxes = [];

          for (var i = 0; i < 12; ++i) {
            var box = BABYLON.Mesh.CreateBox("box" + i, 10, scene);
            box.material = new BABYLON.StandardMaterial("box" + i + "Mat", scene);
            box.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box.position = new BABYLON.Vector3(60 * Math.cos(i * Math.PI / 6), 100, 60 * Math.sin(i * Math.PI / 6));
            box.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.001 });
            //box.rotate(new BABYLON.Vector3(Math.PI / 4, 0, 0));
            boxes.push(box);
          }

          // Enable Collisions
          //scene.collisionsEnabled = true;

          //for (var i = 0; i < boxes.length; ++i) {
            //	boxes[i].checkCollisions = true;
          //}

          var sphere = BABYLON.Mesh.CreateSphere("sphere", 20.0, 15.0, scene, true);
          //sphere.setPhysicsState(BABYLON.PhysicsEngine.SphereImpostor, { mass: 0, friction: 0.0, restitution: 0.0 });
          //sphere.updatePhysicsBody();
          sphere.position.y = 10;
          sphere.material = new BABYLON.StandardMaterial("sphereTexture", scene);
          sphere.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
          scene.beginAnimation(sphere, 0, 100, true);

          var easingFunction = new BABYLON.SineEase();
          easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEIN);

          var getPlanePosition = function () {
            // Use a predicate to get position on the drag wall
            var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == dragWall || mesh == ground; });
            if (pickinfo.hit) {
              return pickinfo.pickedPoint;
            }
            return null;
          };

          //scene.collisionsEnabled = true;
          //sphere.checkCollisions = true;
          //ground.checkCollisions = true;

          var currentMesh;
          var startingPoint;

          var onPointerDown = function (e) {
            if (e.button !== 0) { return; }

            var pickInfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == sphere; });
            if (pickInfo.hit) {
              currentMesh = pickInfo.pickedMesh;
              startingPoint = getPlanePosition();

              if (startingPoint) {
                setTimeout(function () {
                  camera.detachControl(canvas);
                }, 0);
              }
            }
          };

          var onPointerUp = function () {
            if (startingPoint) {
              camera.attachControl(canvas, true);
              startingPoint = null;
              return;
            }
          };

          var onPointerMove = function (e) {
            if (!startingPoint) { return; }

            var current = getPlanePosition();

            if (!current) { return; }

            var pickInfo = scene.pickWithRay(new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0, -1, 0)), function (mesh) { return mesh == ground; });
            var groundDistance = current.y - pickInfo.pickedPoint.y;

            if (groundDistance >= 0 && groundDistance < 50) {
              sphere.material.diffuseColor = new BABYLON.Color3(0.8 - (groundDistance / 100.0), 0, 0.2 + (groundDistance / 100.0));
              //console.log(sphere.material.diffuseColor);
            } else if (groundDistance >= 50 && groundDistance < 100) {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 0.2 + (groundDistance / 100.0), 0.8 - (groundDistance / 100.0));
                //console.log(sphere.material.diffuseColor);
            } else if (groundDistance >= 100 && groundDistance <= 150) {
                sphere.material.diffuseColor = new BABYLON.Color3(0.2 + (groundDistance / 150.0), 1.2 - (groundDistance / 150.0), 0);
            }

            var diff = current.subtract(startingPoint);

            easingFunction.ease(diff.y);
            currentMesh.position.addInPlace(diff);
            currentMesh.position.x = 0;
            currentMesh.position.z = 0;
            startingPoint = current;
          };

          canvas.addEventListener("pointerdown", onPointerDown, false);
          canvas.addEventListener("pointerup", onPointerUp, false);
          canvas.addEventListener("pointermove", onPointerMove, false);

          scene.onDispose = function () {
            canvas.removeEventListener("pointerdown", onPointerDown);
            canvas.removeEventListener("pointerup", onPointerUp);
            canvas.removeEventListener("pointermove", onPointerMove);
          };

        	scene.registerBeforeRender(function () {
        		//console.log(camera.position);
        		for (var i = 0; i < boxes.length; ++i) {
        			if (boxes[i].position.y > 10) {
        				boxes[i].lookAt(sphere.position);
        			} else {
        				//boxes[i].applyImpulse(new BABYLON.Vector3(Math.random(), Math.random(), Math.random()), new BABYLON.Vector3(Math.random(), Math.random(), Math.random()));
        			}
        		}
        	});

          return scene;
        };

        // call the createScene function
        var scene = createScene();

        // run the render loop
        engine.runRenderLoop(function() {
          scene.render();
        });

        // event handler for canvas/window resizing
        window.addEventListener('resize', function() {
          engine.resize();
        });
      });
    </script>
  </body>
</html>

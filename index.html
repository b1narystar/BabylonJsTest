<!--
  Title: index.html
  Summary: babylon.js driver html file for tutorials and the bjs_test video
  Owner: Zachary Fout
  Version: 0.0.1
  Created: 06/20/2016
  Last Modified: 06/21/2016
  Notes: completed basic scene tutorial
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html" charset="utf-8" />
    <title>Babylon - Getting Started</title>
    <!-- link to the latest version of babylon -->
    <script src="./js/babylon.2.4.js"></script>
    <script src="./js/hand.1.2.js"></script>
    <script src="./js/cannon.2.4.js"></script>
    <script src="./js/oimo.2.4.js"></script>
    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      } #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>
    <script>
      window.addEventListener('DOMContentLoaded', function() {
        // get a reference to the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the Babylon 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // create and return a babylon scene
        var createScene = function() {
          // create a basic BJS Scene object
          var scene = new BABYLON.Scene(engine);

          // create an ArcRotateCamera with rotation angles of 3pi/2 -> x,
          // pi/8 -> y, radius 50 units, centered at the origin
          var camera = new BABYLON.ArcRotateCamera('camera', 3 * Math.PI / 2,
                             Math.PI / 8, 50, BABYLON.Vector3.Zero(), scene);

          // attach the camera to the canvas element
          camera.attachControl(canvas, true);

          // create a hemispheric light pointed at the sky
          var light = new BABYLON.HemisphericLight('hemi',
                            new BABYLON.Vector3(0, 1, 0), scene);

          // create a basic box (name, size, scene, updatable, orientation)
          var box = BABYLON.Mesh.CreateBox('box', 6.0, scene,
                      false, BABYLON.Mesh.DOUBLESIDE);

          // create a sphere (name, # of segments, diameter, scene, updatable, orientation)
          var sphere = BABYLON.Mesh.CreateSphere('sphere', 10.0, 10.0, scene,
                         false, BABYLON.Mesh.DOUBLESIDE);

          // create a basic plane (name, size, scene, updatable, orientation)
          var plane = BABYLON.Mesh.CreatePlane('plane', 10.0, scene,
                        false, BABYLON.Mesh.DOUBLESIDE);

          // create a disc (name, radius, tessellation, scene,
          // updatable, orientation)
          var disc = BABYLON.Mesh.CreateDisc('disc', 5, 30, scene,
                       false, BABYLON.Mesh.DOUBLESIDE);

          // create a cylinder (name, height, diamTop, diamBottom,
          // tessellation, height subdivisions, scene, updatable, orientation)
          var cylinder = BABYLON.Mesh.CreateCylinder('cylinder', 3, 3, 3, 6,
                           1, scene, false, BABYLON.Mesh.DOUBLESIDE);

          // create a torus (name, diameter, thickness,
          // tessellation, scene, updatable)
          var torus = BABYLON.Mesh.CreateTorus('torus', 5, 1, 10, scene, false);

          // create a knot (name, radius, tube, radialSegments,
          // tubularSegments, p, q, scene)
          var knot = BABYLON.Mesh.CreateTorusKnot('knot', 2, 0.5, 128,
                       64, 2, 3, scene)

          // create a lines mesh (name, array of vectors, scene)
          var lines = BABYLON.Mesh.CreateLines('lines', [
            new BABYLON.Vector3(-10, 0, 0),
            new BABYLON.Vector3(10, 0, 0),
            new BABYLON.Vector3(0, 0, -10),
            new BABYLON.Vector3(0, 0, 10)
          ], scene);

          // create a ribbon
          // first create some paths along an exponential function
          var exponentialPath = function(p) {
            var path = [];
            for (var i = -10; i < 10; ++i) {
              path.push(new BABYLON.Vector3(p, i,
                              Math.sin(p / 3) * 5 *
                              Math.exp(-(i - p) * (i - p) / 60) + i / 3)
              );
            } return path;
          }

          // now populate an array with path vectors
          var arrayOfPaths = [];
          for (var p = 0; p < 20; ++p) {
            arrayOfPaths[p] = exponentialPath(p);
          }

          // create the ribbon (name, paths, closeArray,
          // closePath, offset, scene, updatable, orientation)
          var ribbon = BABYLON.Mesh.CreateRibbon('ribbon',
                         arrayOfPaths, false, false, 0, scene,
                         false, BABYLON.Mesh.DOUBLESIDE);

          // reposition elements away from the origin
          box.position = new BABYLON.Vector3(-10, 0, 0);
          sphere.position = new BABYLON.Vector3(0, 10, 0);
          plane.position.z = 10;
          cylinder.position.z = 10;
          torus.position.x = 10;
          knot.position.y = -10;
          ribbon.position = new BABYLON.Vector3(-10, -10, 20);

          // return the created scene
          return scene;
        }

        // call the createScene function
        var scene = createScene();

        // run the render loop
        engine.runRenderLoop(function() {
          scene.render();
        });

        // event handler for canvas/window resizing
        window.addEventListener('resize', function() {
          engine.resize();
        });
      });
    </script>
  </body>
</html>
